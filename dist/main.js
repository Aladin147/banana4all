(()=>{var e={62:e=>{"use strict";e.exports=require("photoshop")},210:(e,t,o)=>{const{app:a,core:n}=o(62),i=o(384);class r{static async hasActiveSelection(){try{return void 0!==await n.executeAsModal(async()=>{const e=o(62).action.batchPlay;return(await e([{_obj:"get",_target:{_ref:"document",_enum:"ordinal",_value:"targetEnum"}}],{}))[0].selection})}catch{return!1}}static async getSelectionBounds(){if(!await this.hasActiveSelection())return null;try{const e=await n.executeAsModal(async()=>{const e=o(62).action.batchPlay;return(await e([{_obj:"get",_target:{_ref:"document",_enum:"ordinal",_value:"targetEnum"}}],{}))[0].selection});return{left:e.left._value,top:e.top._value,right:e.right._value,bottom:e.bottom._value,width:e.right._value-e.left._value,height:e.bottom._value-e.top._value}}catch(e){return console.error("Error getting selection bounds:",e),null}}static async createImageLayer(e,t="AI Generated",r=null,l=null){return await n.executeAsModal(async()=>{const n=a.activeDocument,s=o(897).storage.localFileSystem,c=o(62).action.batchPlay;try{const o=await s.getDataFolder(),a=await o.createFile(`${i.photoshop.tempFilePrefix}${Date.now()}.png`,{overwrite:!0}),d=await e.arrayBuffer(),u=new Uint8Array(d);await a.write(u);const g={_obj:"placeEvent",null:{_path:s.createSessionToken(await s.getEntryWithUrl(a.nativePath)),_kind:"local"},freeTransformCenterState:{_enum:"quadCenterState",_value:"QCSAverage"},_options:{dialogOptions:"dontDisplay"}};await c([g],{synchronousExecution:!1,modalBehavior:"wait"});const h=n.activeLayers[0];if(h&&(h.name=t),l&&h){const e=h.bounds.width,t=h.bounds.height,o=l.width,a=l.height;if(console.log(`Layer size: ${e}x${t}, expected: ${o}x${a}`),Math.abs(e-o)>1||Math.abs(t-a)>1){console.log("Resizing layer to match expected dimensions...");const n=o/e*100,i=a/t*100;console.log(`Scale: ${n.toFixed(2)}% x ${i.toFixed(2)}%`),await c([{_obj:"transform",_target:[{_ref:"layer",_enum:"ordinal",_value:"targetEnum"}],freeTransformCenterState:{_enum:"quadCenterState",_value:"QCSCorner0"},width:{_unit:"percentUnit",_value:n},height:{_unit:"percentUnit",_value:i},interfaceIconFrameDimmed:{_enum:"interpolationType",_value:"bicubic"}}],{}),console.log(`Layer resized to ${h.bounds.width}x${h.bounds.height}`)}else console.log("Layer size matches expected dimensions, no resize needed")}if(r&&h){console.log(`Moving layer to position (${r.x}, ${r.y})`);const e=h.bounds,t=e.left,o=e.top,a=r.x-t,n=r.y-o;console.log(`Layer currently at (${t}, ${o}), moving by (${a}, ${n})`),await c([{_obj:"move",_target:[{_ref:"layer",_enum:"ordinal",_value:"targetEnum"}],to:{_obj:"offset",horizontal:{_unit:"pixelsUnit",_value:a},vertical:{_unit:"pixelsUnit",_value:n}}}],{}),console.log(`Layer moved to (${h.bounds.left}, ${h.bounds.top})`)}return await new Promise(e=>setTimeout(e,i.photoshop.processingDelay)),await a.delete(),h}catch(e){throw console.error("Error placing image:",e),e}})}static async exportSelectionAsImage(){if(!await this.hasActiveSelection())throw new Error("No active selection to export");return await n.executeAsModal(async()=>{const e=o(62).action.batchPlay,t=o(897),n=t.storage.localFileSystem,i=await n.getDataFolder();try{const o=await this.getSelectionBounds();console.log(`Selection bounds: ${o.width}x${o.height}`),await e([{_obj:"copyMerged"}],{}),await e([{_obj:"make",_target:[{_ref:"document"}],width:{_unit:"pixelsUnit",_value:o.width},height:{_unit:"pixelsUnit",_value:o.height},resolution:{_unit:"densityUnit",_value:72},mode:{_enum:"newDocumentMode",_value:"RGBColorMode"},fill:{_enum:"fill",_value:"white"}}],{});const r=a.activeDocument;console.log(`Created temp document: ${r.id}`),await e([{_obj:"paste"}],{}),await e([{_obj:"flattenImage"}],{});const l=await i.createFile(`selection_${Date.now()}.png`,{overwrite:!0}),s=n.createSessionToken(l);await e([{_obj:"save",as:{_obj:"PNGFormat",method:{_enum:"PNGMethod",_value:"quick"}},in:{_path:s,_kind:"local"},copy:!1}],{}),console.log("Selection exported to temp file");const c=await l.read({format:t.storage.formats.binary}),d=new Blob([c],{type:"image/png"});return await e([{_obj:"close",saving:{_enum:"yesNo",_value:"no"}}],{}),console.log("Temp document closed"),await l.delete(),d}catch(t){console.error("Error in exportSelectionAsImage:",t);try{a.documents.length>1&&await e([{_obj:"close",saving:{_enum:"yesNo",_value:"no"}}],{})}catch(e){console.error("Cleanup error:",e)}throw t}})}static async createMaskFromSelection(){if(!await this.hasActiveSelection())throw new Error("No active selection to create mask from");return await n.executeAsModal(async()=>{const e=o(62).action.batchPlay,t=o(897),n=t.storage.localFileSystem,i=await n.getDataFolder();try{const o=await this.getSelectionBounds();console.log(`Creating mask: ${o.width}x${o.height}`),await e([{_obj:"make",_target:[{_ref:"document"}],width:{_unit:"pixelsUnit",_value:o.width},height:{_unit:"pixelsUnit",_value:o.height},resolution:{_unit:"densityUnit",_value:72},mode:{_enum:"newDocumentMode",_value:"grayscale"},fill:{_enum:"fill",_value:"white"}}],{});const r=a.activeDocument;console.log(`Created mask document: ${r.id}`);const l=await i.createFile(`mask_${Date.now()}.png`,{overwrite:!0}),s=n.createSessionToken(l);await e([{_obj:"save",as:{_obj:"PNGFormat",method:{_enum:"PNGMethod",_value:"quick"}},in:{_path:s,_kind:"local"},copy:!1}],{}),console.log("Mask exported to temp file");const c=await l.read({format:t.storage.formats.binary}),d=new Blob([c],{type:"image/png"});return await e([{_obj:"close",saving:{_enum:"yesNo",_value:"no"}}],{}),console.log("Mask document closed"),await l.delete(),d}catch(t){console.error("Error in createMaskFromSelection:",t);try{a.documents.length>1&&await e([{_obj:"close",saving:{_enum:"yesNo",_value:"no"}}],{})}catch(e){console.error("Cleanup error:",e)}throw t}})}static async exportCroppedRegion(e){return await n.executeAsModal(async()=>{const t=o(62).action.batchPlay,n=o(897),i=n.storage.localFileSystem,r=await i.getDataFolder();try{const o=a.activeDocument.id;console.log(`Cropping region: ${e.width}x${e.height} at (${e.left}, ${e.top})`),await t([{_obj:"duplicate",_target:[{_ref:"document",_enum:"ordinal",_value:"targetEnum"}],name:"temp_crop"}],{});const i=a.activeDocument,l=i.id;await t([{_obj:"flattenImage"}],{}),await t([{_obj:"crop",angle:{_unit:"angleUnit",_value:0},to:{_obj:"rectangle",top:{_unit:"pixelsUnit",_value:e.top},left:{_unit:"pixelsUnit",_value:e.left},bottom:{_unit:"pixelsUnit",_value:e.top+e.height},right:{_unit:"pixelsUnit",_value:e.left+e.width}},delete:!0}],{}),console.log(`Cropped temp doc to: ${i.width}x${i.height}`);const s=await r.createFile(`crop_${Date.now()}.png`,{overwrite:!0});await i.saveAs.png(s,{interlaced:!1,compression:6},!0),console.log("Cropped region saved to temp file");const c=await s.read({format:n.storage.formats.binary}),d=new Blob([c],{type:"image/png"});return await t([{_obj:"close",_target:[{_ref:"document",_id:l}],saving:{_enum:"yesNo",_value:"no"}}],{}),await t([{_obj:"select",_target:[{_ref:"document",_id:o}]}],{}),console.log("Returned to original document"),await s.delete(),d}catch(e){console.error("Error in exportCroppedRegion:",e);try{a.documents.length>1&&await t([{_obj:"close",saving:{_enum:"yesNo",_value:"no"}}],{})}catch(e){console.error("Cleanup error:",e)}throw e}})}static async exportSelectionContent(){return await n.executeAsModal(async()=>{const e=o(62).action.batchPlay,t=o(897),n=t.storage.localFileSystem,i=await n.getDataFolder();try{const o=a.activeDocument.id,n=(await e([{_obj:"get",_target:{_ref:"document",_enum:"ordinal",_value:"targetEnum"}}],{}))[0].selection,r={left:n.left._value,top:n.top._value,right:n.right._value,bottom:n.bottom._value,width:n.right._value-n.left._value,height:n.bottom._value-n.top._value};console.log(`Exporting selection content: ${r.width}x${r.height}`),await e([{_obj:"copyMerged"}],{}),await e([{_obj:"make",_target:[{_ref:"document"}],width:{_unit:"pixelsUnit",_value:r.width},height:{_unit:"pixelsUnit",_value:r.height},resolution:{_unit:"densityUnit",_value:72},mode:{_enum:"newDocumentMode",_value:"RGBColorMode"},fill:{_enum:"fill",_value:"white"}}],{});const l=a.activeDocument,s=l.id;console.log(`Created temp doc: ${l.width}x${l.height}`),await e([{_obj:"paste"}],{}),await e([{_obj:"flattenImage"}],{});const c=await i.createFile(`selection_${Date.now()}.png`,{overwrite:!0});await l.saveAs.png(c,{interlaced:!1,compression:6},!0),console.log("Selection content saved to temp file");const d=await c.read({format:t.storage.formats.binary}),u=new Blob([d],{type:"image/png"});return await e([{_obj:"close",_target:[{_ref:"document",_id:s}],saving:{_enum:"yesNo",_value:"no"}}],{}),await e([{_obj:"select",_target:[{_ref:"document",_id:o}]}],{}),console.log("Returned to original document"),await c.delete(),u}catch(t){console.error("Error in exportSelectionContent:",t);try{a.documents.length>1&&await e([{_obj:"close",saving:{_enum:"yesNo",_value:"no"}}],{})}catch(e){console.error("Cleanup error:",e)}throw t}})}static async exportSelectionAndMask(){if(!await this.hasActiveSelection())throw new Error("No active selection to export");return await n.executeAsModal(async()=>{const e=o(62).action.batchPlay,t=o(897),n=t.storage.localFileSystem,i=await n.getDataFolder();try{const o=a.activeDocument.id,n=(await e([{_obj:"get",_target:{_ref:"document",_enum:"ordinal",_value:"targetEnum"}}],{}))[0].selection,r={left:n.left._value,top:n.top._value,right:n.right._value,bottom:n.bottom._value,width:n.right._value-n.left._value,height:n.bottom._value-n.top._value};console.log(`Selection bounds: ${r.width}x${r.height}`),await e([{_obj:"make",new:{_ref:"channel"},using:{_ref:"channel",_enum:"channel",_value:"selection"},name:"banana4all_temp"}],{}),console.log("Selection saved to channel"),await e([{_obj:"copyMerged"}],{}),await e([{_obj:"make",_target:[{_ref:"document"}],width:{_unit:"pixelsUnit",_value:r.width},height:{_unit:"pixelsUnit",_value:r.height},resolution:{_unit:"densityUnit",_value:72},mode:{_enum:"newDocumentMode",_value:"RGBColorMode"},fill:{_enum:"fill",_value:"white"}}],{}),await e([{_obj:"paste"}],{}),await e([{_obj:"flattenImage"}],{});const l=a.activeDocument,s=l.id;console.log(`Content doc size: ${l.width}x${l.height} (expected: ${r.width}x${r.height})`);const c=await i.createFile(`content_${Date.now()}.png`,{overwrite:!0});await l.saveAs.png(c,{interlaced:!1,compression:6},!0),console.log("Content saved");const d=await c.read({format:t.storage.formats.binary}),u=new Blob([d],{type:"image/png"});console.log(`Content: ${u.size} bytes`),await c.delete(),console.log("Creating mask..."),await e([{_obj:"make",_target:[{_ref:"document"}],width:{_unit:"pixelsUnit",_value:r.width},height:{_unit:"pixelsUnit",_value:r.height},resolution:{_unit:"densityUnit",_value:72},mode:{_enum:"newDocumentMode",_value:"grayscale"},fill:{_enum:"fill",_value:"white"}}],{});const g=a.activeDocument;if(console.log(`Mask doc: ${g?g.id:"null"}`),!g)throw new Error("Failed to create mask document");const h=await i.createFile(`mask_${Date.now()}.png`,{overwrite:!0});await g.saveAs.png(h,{interlaced:!1,compression:6},!0),console.log("Mask saved");const m=await h.read({format:t.storage.formats.binary}),p=new Blob([m],{type:"image/png"});return console.log(`Mask: ${p.size} bytes`),await h.delete(),console.log(`Closing temp docs: content=${s}, mask=${g.id}, original=${o}`),g.id!==o&&await e([{_obj:"close",_target:[{_ref:"document",_id:g.id}],saving:{_enum:"yesNo",_value:"no"}}],{}),s!==o&&await e([{_obj:"close",_target:[{_ref:"document",_id:s}],saving:{_enum:"yesNo",_value:"no"}}],{}),await e([{_obj:"select",_target:[{_ref:"document",_id:o}]}],{}),console.log("Returned to original document"),await e([{_obj:"set",_target:[{_ref:"channel",_enum:"channel",_value:"selection"}],to:{_ref:"channel",_name:"banana4all_temp"}}],{}),console.log("Selection restored"),{contentBlob:u,maskBlob:p,bounds:r}}catch(t){console.error("Error in exportSelectionAndMask:",t);try{a.documents.length>1&&await e([{_obj:"close",saving:{_enum:"yesNo",_value:"no"}}],{})}catch(e){console.error("Cleanup error:",e)}throw t}})}static async saveSelectionToChannel(e="temp_selection_backup"){return await n.executeAsModal(async()=>{const t=o(62).action.batchPlay;try{return await t([{_obj:"make",new:{_ref:"channel"},using:{_ref:"channel",_enum:"channel",_value:"selection"},name:e}],{}),console.log(`Selection saved to channel: ${e}`),!0}catch(e){return console.error("Error saving selection to channel:",e),!1}})}static async restoreSelectionFromChannel(e="temp_selection_backup"){return await n.executeAsModal(async()=>{const t=o(62).action.batchPlay;try{return await t([{_obj:"set",_target:[{_ref:"channel",_enum:"channel",_value:"selection"}],to:{_ref:"channel",_name:e}}],{}),console.log(`Selection restored from channel: ${e}`),!0}catch(e){return console.error("Error restoring selection from channel:",e),!1}})}static async deleteChannel(e="temp_selection_backup"){return await n.executeAsModal(async()=>{const t=o(62).action.batchPlay;try{return await t([{_obj:"delete",_target:[{_ref:"channel",_name:e}]}],{}),console.log(`Channel deleted: ${e}`),!0}catch(e){return console.error("Error deleting channel:",e),!1}})}static async getSelectionWithPadding(e=i.phase2.selectionPadding){const t=await this.getSelectionBounds();return t?{left:t.left-e,top:t.top-e,right:t.right+e,bottom:t.bottom+e,width:t.width+2*e,height:t.height+2*e,padding:e}:null}static async createLayerMaskFromSelection(e,t=0){return await n.executeAsModal(async()=>{const a=o(62).action.batchPlay;try{await a([{_obj:"select",_target:[{_ref:"layer",_id:e.id}]}],{}),t>0&&(await a([{_obj:"feather",radius:{_unit:"pixelsUnit",_value:t}}],{}),console.log(`Applied ${t}px feather to selection`)),await a([{_obj:"make",new:{_ref:"channel"},at:{_ref:"mask",_enum:"mask",_value:"revealSelection"},using:{_ref:"channel",_enum:"channel",_value:"selection"}}],{}),console.log("Layer mask created from selection")}catch(e){throw console.error("Error creating layer mask:",e),e}})}static async applyFeatherToLayerMask(e,t=i.phase2.autoFeatherRadius){return console.warn("applyFeatherToLayerMask is deprecated, use createLayerMaskFromSelection instead"),await this.createLayerMaskFromSelection(e,t)}static async createLayerGroup(e){return await n.executeAsModal(async()=>{const t=o(62).action.batchPlay;try{await t([{_obj:"make",_target:[{_ref:"layerSection"}],using:{_obj:"layerSection",name:e}}],{});const o=a.activeDocument.activeLayers[0];return console.log(`Created layer group: ${e}`),o}catch(e){throw console.error("Error creating layer group:",e),e}})}static async addLayerToGroup(e,t){return await n.executeAsModal(async()=>{const a=o(62).action.batchPlay;try{await a([{_obj:"move",_target:[{_ref:"layer",_id:e.id}],to:{_ref:"layer",_id:t.id},adjustment:!1}],{}),console.log(`Added layer "${e.name}" to group "${t.name}"`)}catch(e){throw console.error("Error adding layer to group:",e),e}})}static async downloadImageAsBlob(e){const t=await fetch(e);if(!t.ok)throw new Error(`Failed to download image: ${t.status} ${t.statusText}`);return await t.blob()}static async showProgress(e){console.log(`[Banana4All] ${e}`)}}e.exports?e.exports=r:window.PhotoshopUtils=r},384:e=>{const t={api:{defaultProxyUrl:"http://localhost:3000",proxyHealthTimeout:5e3,defaultProvider:"openrouter",defaultModel:"google/gemini-2.5-flash-image"},photoshop:{processingDelay:1e3,tempFilePrefix:"temp_",defaultLayerNamePrefix:"AI: "},generation:{defaultPromptPrefix:"Generate an image of",maxPromptLength:1e3,imageFormat:"png"},phase2:{selectionPadding:10,autoFeatherRadius:2,maxVariants:4,enableSeeding:!0},ui:{showApiKeyWarning:!0,enableDebugLogging:!1},models:{"google/gemini-2.5-flash-image":{name:"Gemini 2.5 Flash",cost:"~$0.001",speed:"~8 sec",features:["text-to-image","fast","identity-preserving"],watermarking:"SynthID"}}};e.exports?e.exports=t:window.CONFIG=t},897:e=>{"use strict";e.exports=require("uxp")}},t={};function o(a){var n=t[a];if(void 0!==n)return n.exports;var i=t[a]={exports:{}};return e[a](i,i.exports,o),i.exports}const{app:a}=o(62),n=o(210),i=o(384);class r{constructor(e,t=i.api.defaultProxyUrl,o=i.api.defaultProvider,a=null){this.apiKey=e,this.proxyUrl=t,this.provider=o,this.model=a||i.api.defaultModel}async generateImage(e){const t=await fetch(`${this.proxyUrl}/api/generate`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({apiKey:this.apiKey,model:this.model,prompt:e,provider:this.provider})});if(!t.ok){let e="Unknown error";try{const o=await t.json();e=o.error&&"object"==typeof o.error?o.error.message||JSON.stringify(o.error):o.error||o.message||"Unknown error",console.error("Proxy error:",o)}catch(o){e=`HTTP ${t.status}: ${t.statusText}`}throw new Error(`${e}`)}const o=await t.json();if(o.candidates&&o.candidates[0]?.content?.parts)for(const t of o.candidates[0].content.parts)if(t.inline_data||t.inlineData){const o=t.inline_data||t.inlineData,a=o.data,n=o.mime_type||o.mimeType||"image/jpeg",i=atob(a),r=new Uint8Array(i.length);for(let e=0;e<i.length;e++)r[e]=i.charCodeAt(e);return{imageBlob:new Blob([r],{type:n}),prompt:e}}throw new Error("No image data returned from API")}async checkProxyHealth(){try{const e=new AbortController,t=setTimeout(()=>e.abort(),i.api.proxyHealthTimeout),o=await fetch(`${this.proxyUrl}/health`,{method:"GET",signal:e.signal});return clearTimeout(t),o.ok}catch(e){return!1}}async inpaintSelection(e,t,o,a){const n=t.size/1048576;console.log(`Content size: ${n.toFixed(2)}MB`),n>10&&console.warn("Image is too large for API (>10MB). Consider using smaller selections.");const i=await this.blobToBase64(t),r=`Edit only the selected area in this image crop: ${e}. Keep all other elements, lighting, colors, and background completely unchanged.`;console.log(`Semantic inpainting prompt: ${r}`);const l=await fetch(`${this.proxyUrl}/api/generate`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({apiKey:this.apiKey,model:this.model,prompt:r,provider:this.provider,mode:"inpaint",imageData:i,bounds:a})});if(!l.ok){let e="Unknown error";try{const t=await l.json();e=t.error&&"object"==typeof t.error?t.error.message||JSON.stringify(t.error):t.error||t.message||"Unknown error",console.error("Inpainting error:",t)}catch(t){e=`HTTP ${l.status}: ${l.statusText}`}throw new Error(`${e}`)}const s=await l.json();if(s.candidates&&s.candidates[0]?.content?.parts)for(const t of s.candidates[0].content.parts)if(t.inline_data||t.inlineData){const o=t.inline_data||t.inlineData,n=o.data,i=o.mime_type||o.mimeType||"image/jpeg",r=atob(n),l=new Uint8Array(r.length);for(let e=0;e<r.length;e++)l[e]=r.charCodeAt(e);return{imageBlob:new Blob([l],{type:i}),prompt:e,mode:"inpaint",bounds:a}}throw new Error("No image data returned from API")}async generateVariants(e,t,o="full",a=null,n=null,i=null){const r=[],l=Date.now();for(let s=0;s<t;s++)try{let c;console.log(`Generating variant ${s+1} of ${t}...`),c="inpaint"===o&&a&&n&&i?await this.inpaintSelection(e,a,n,i):await this.generateImage(e),c.variantIndex=s+1,c.mode=o,r.push(c),console.log(`Variant ${s+1} completed in ${Date.now()-l}ms`)}catch(e){console.error(`Error generating variant ${s+1}:`,e)}if(0===r.length)throw new Error("All variant generations failed");return r}async blobToBase64(e){const t=await e.arrayBuffer(),o=new Uint8Array(t);let a="";for(let e=0;e<o.length;e++)a+=String.fromCharCode(o[e]);return btoa(a)}}class l{constructor(){this.currentMode=i.phase2.defaultMode,this.hasSelection=!1,this.variantCount=1,this.selectionCheckInterval=null}async updateMode(){this.hasSelection=await n.hasActiveSelection(),this.updateUI()}getMode(){const e=this.hasSelection&&"inpaint"===this.currentMode?"inpaint":"full";return console.log(`getMode: hasSelection=${this.hasSelection}, currentMode=${this.currentMode}, returning=${e}`),e}setMode(e){console.log(`ModeManager.setMode called with: ${e}`),this.currentMode=e,i.phase2.rememberMode&&localStorage.setItem("banana4all_mode",e),this.updateUI(),console.log(`Mode is now: ${this.currentMode}`)}loadSavedMode(){if(i.phase2.rememberMode){const e=localStorage.getItem("banana4all_mode");e&&(this.currentMode=e)}}updateUI(){const e=document.getElementById("mode-hint");e&&(this.hasSelection?(this.currentMode="inpaint",e.textContent="✂️ Selection detected - Will inpaint into selected area",e.style.color="#f59e0b",e.style.fontSize="12px"):(this.currentMode="full",e.textContent="🖼️ No selection - Will generate new layer",e.style.color="#999",e.style.fontSize="12px"))}startSelectionMonitoring(){this.selectionCheckInterval=setInterval(async()=>{await this.updateMode()},500)}stopSelectionMonitoring(){this.selectionCheckInterval&&(clearInterval(this.selectionCheckInterval),this.selectionCheckInterval=null)}}document.addEventListener("DOMContentLoaded",()=>{const e=document.getElementById("apiKey"),t=document.getElementById("prompt"),o=document.getElementById("generate"),s=document.getElementById("variantCount"),c=new l,d=localStorage.getItem("banana4all_api_key");d&&(e.value=d);const u=()=>{const t=e.value?e.value.trim():"";t&&(localStorage.setItem("banana4all_api_key",t),console.log("API key saved"))};e.addEventListener("change",u),e.addEventListener("input",u),s.addEventListener("change",()=>{c.variantCount=parseInt(s.value),console.log("Variant count set to:",c.variantCount)}),(async()=>{await c.updateMode(),c.startSelectionMonitoring()})(),o.addEventListener("click",async()=>{if(o.disabled)return void console.log("Button already disabled, ignoring click");const l=e.value?e.value.trim():"",s=t.value?t.value.trim():"";if(console.log("Generate clicked"),console.log("API Key length:",l.length),console.log("Prompt:",s),l&&s)if(a.activeDocument)try{o.disabled=!0,o.innerHTML='<span class="btn-icon">⏳</span> Generating...';const e=new r(l,i.api.defaultProxyUrl,i.api.defaultProvider,"google/gemini-2.5-flash-image");if(!await e.checkProxyHealth())throw new Error("Proxy server not running. Start it with: cd proxy-server && npm start");const t=c.getMode();let a;console.log(`Generation mode: ${t}`);let d=null;if("inpaint"===t){if(console.log("Starting semantic inpainting workflow..."),!await n.hasActiveSelection())throw new Error("No active selection found. Please create a selection first.");const t=await n.getSelectionBounds(),o=i.phase2.selectionPadding,r={left:Math.max(0,t.left-o),top:Math.max(0,t.top-o),width:t.width+2*o,height:t.height+2*o};console.log(`Selection: ${t.width}x${t.height} at (${t.left}, ${t.top})`),console.log(`Padded crop: ${r.width}x${r.height} at (${r.left}, ${r.top})`),await n.saveSelectionToChannel("banana4all_temp"),console.log("Selection saved to channel");const l=await n.exportCroppedRegion(r);console.log(`Cropped region exported: ${l.size} bytes (${(l.size/1048576).toFixed(2)} MB)`),a=await e.inpaintSelection(s,l,null,t),a.expectedWidth=r.width,a.expectedHeight=r.height,d={x:r.left,y:r.top},console.log(`Will composite result at position (${d.x}, ${d.y})`),console.log(`Expected dimensions: ${r.width}x${r.height}`)}else console.log("Generating full image..."),a=await e.generateImage(s);const u=`${i.photoshop.defaultLayerNamePrefix}${s.substring(0,30)}`;console.log("Creating layer with image blob, size:",a.imageBlob.size);const g="inpaint"===t?{width:a.expectedWidth,height:a.expectedHeight}:null,h=await n.createImageLayer(a.imageBlob,u,d,g);if("inpaint"===t){console.log("Creating layer mask from selection...");try{await n.restoreSelectionFromChannel("banana4all_temp"),console.log("Selection restored, creating mask..."),await n.createLayerMaskFromSelection(h,i.phase2.autoFeatherRadius),console.log("Layer mask created with feathering"),await n.deleteChannel("banana4all_temp")}catch(e){console.error("Failed to create layer mask:",e);try{await n.deleteChannel("banana4all_temp")}catch(e){console.error("Failed to clean up channel:",e)}}}console.log("Generation complete!")}catch(e){console.error("Generation error:",e);let t=e.message;t.includes("User not found")||t.includes("401")?t="Invalid API key or account not found. Please:\n1. Verify your OpenRouter API key at openrouter.ai/keys\n2. Make sure your account is active\n3. Try generating a new API key":t.includes("API key")||t.includes("API_KEY_INVALID")?t="Invalid API key. Please check your OpenRouter API key.":t.includes("quota")||t.includes("RESOURCE_EXHAUSTED")?t="API quota exceeded. Please check your billing.":(t.includes("SAFETY")||t.includes("blocked"))&&(t="Content blocked by safety filters. Please modify your prompt."),await a.showAlert(`Error: ${t}`)}finally{o.disabled=!1,o.innerHTML='<span class="btn-icon">✨</span> Generate'}else await a.showAlert("Please open a document first.");else await a.showAlert("Please enter your OpenRouter API key and a prompt.")})})})();